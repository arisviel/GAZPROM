FUNCTION_BLOCK FB_ST_REG_CASCADE
TCYCLE:= ANY_TO_REAL(__SYSVA_TCYCYCTIME)/1000; 

(***********************Присвоение входных значений внутренним************)

    XMMX1 := COMM1;(*Ручное управление.*)
    //Для корректируюещго параметра. перевод в автоматический режим.
    IF XMMX1 THEN        
        XMMX2 := TRUE; 
        COMM2 := TRUE;
    ELSE
        XMMX2 := COMM2;
    END_IF;

    XRPX := CRPX;(*Ремонт*)      
    XRCX := IRCX;(*Дистанционное управление*)  
    XLCX := ILCX;(*Местное управление*)       
    
    XIMX := CIMX;
    
    ///Если есть эмуляция то заменяем входное значение. LCPX - Обратное положение.Ток 
    IF XIMX THEN      
        IF (SAPH-SAPL) <> 0 THEN
            LCPX := (1.0-((SAPH-LCPX_Scada)/(SAPH-SAPL)))*(SHSO-SLSO) + SLSO;   
        END_IF;
    ELSE             
        LCPX := ICPX;
        LSPP := XSPP;
        LCPX_Scada := XCPP;
    END_IF;    

(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Проверка границ диапазона шкалы датчика************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
    /////////////////
    ///1
    ///////////////
    (***********************Проверка пропорционального коэффициента************)
    IF SPCX1 < 0.0 THEN
        SPCX1 := SPCX1_prev;
    END_IF; 
    (***********************Проверка интегрального коэффициента************)
    IF SICX1 < T#1s THEN
        SICX1 := T#1s;
    END_IF;  
    (***********************Проверка дифференциальный коэффициент************)
    IF SDCX1 < 0.0 THEN
        SDCX1 := SDCX1_prev;
    END_IF;
    (***********************Проверка зоны нечувствительности коэффициента(Метрвая зона)************)
    IF SDBX1 < 0.0 THEN
        SDBX1 := SDBX1_prev;
    END_IF;  
    
    /////////////////
    ///2
    ///////////////
    (***********************Проверка пропорционального коэффициента************)
    IF SPCX2 < 0.0 THEN
        SPCX2 := SPCX2_prev;
    END_IF; 
    (***********************Проверка интегрального коэффициента************)
    IF SICX2 < T#1s THEN
        SICX2 := T#1s;
    END_IF;  
    (***********************Проверка дифференциальный коэффициент************)
    IF SDCX2 < 0.0 THEN
        SDCX2 := SDCX2_prev;
    END_IF;
    (***********************Проверка зоны нечувствительности коэффициента(Метрвая зона)************)
    IF SDBX2 < 0.0 THEN
        SDBX2 := SDBX2_prev;
    END_IF;        
    
    (***********************Проверка максимального управления.************)
    IF SSPH1 > SAPH THEN
        SSPH1 := SAPH;
    END_IF;
    (***********************Проверка минимального управления.************)
    IF (SSPL1 < SAPL) THEN
        SSPL1 := SAPL;
    END_IF;

    (***********************Проверка времени рассогласования.************)
    IF SMVT < 0.0 THEN 
        SMVT := SMVT_prev;    
    END_IF;
    (***********************Проверка задания процента открытия.************)   
    (*********Добаленно специально что бы при эмуляции проверить обрыв или КЗ**************)
    IF NOT XIMX THEN
        IF SSPO > SAPH THEN
            SSPO := SAPH;
        END_IF;
        IF SSPO < SAPL THEN
            SSPO := SAPL;
        END_IF;
    END_IF; 
    IF NOT XIMX THEN
        IF SEPX > SAPH THEN
            SEPX := SAPH;
        END_IF;
        IF SEPX < SAPL THEN
            SEPX := SAPL;
        END_IF;
    END_IF;
    IF NOT XIMX THEN
        IF SENX > SAPH THEN   (*ЗНАЧЕНИЕ ДЛЯ БЛОКИРОВКИ/НОРМАЛЬНОГО ОСТАНОВА*)
            SENX := SAPH;
        END_IF;
        IF SENX < SAPL THEN
            SENX := SAPL;
        END_IF;      
    END_IF;
                                            
    //1
   (*********Ограничение на ввод уставки регулирования**************)
   IF SAPV1 > SHAP1 THEN
        SAPV1 := SHAP1;
   END_IF;
   IF SAPV1 < SLAP1 THEN
        SAPV1 := SLAP1;
   END_IF; 
   //2
   (*Задание основного параметра (расхода) в различных режимах*)
        (*Интеграция функции для задания от АРМ,панели,резерва*)
        IF QR11 THEN QR1:=TRUE; END_IF;
        IF QR22 THEN QR2:=TRUE; END_IF;
        IF QR33 THEN QR3:=TRUE; END_IF;
        IF QR44 THEN QR4:=TRUE; END_IF; (*Сигнал о включенном 4ом режиме в шаблон)

            (*оганизация переключения подрежимов*)
            (*ПЕРВЫЙ РЕЖИМ*)
            IF RSS1 THEN
                RSS1 :=FALSE;
                END_IF;
        
            IF QR1 AND NOT RSS1H THEN
                RSS1 :=TRUE;
                RSS1H :=TRUE;
                END_IF;
                
            IF NOT QR1 THEN
                RSS1H :=FALSE;
                END_IF;
                
            (*ВТОРОЙ РЕЖИМ*)
            IF RSS2 THEN
                RSS2 :=FALSE;
                END_IF;

            IF QR2 AND NOT RSS2H THEN
                RSS2 :=TRUE;
                RSS2H :=TRUE;
                END_IF;

            IF NOT QR2 THEN
                RSS2H :=FALSE;
                END_IF;
                
            (*ТРЕТИЙ РЕЖИМ*)

            IF RSS3 THEN
                RSS3 :=FALSE;
                END_IF;

            IF QR3 AND NOT RSS3H THEN
                RSS3 :=TRUE;
                RSS3H :=TRUE;
                END_IF;
                
            IF NOT QR3 THEN
                RSS3H :=FALSE;
                END_IF;
                
            (*ЧЕТВЕРТЫЙ РЕЖИМ*)

            IF RSS4 THEN
                RSS4 :=FALSE;
                END_IF;

            IF QR4 AND NOT RSS4H THEN
                RSS4 :=TRUE;
                RSS4H :=TRUE;
                END_IF;
                
            IF NOT QR4 THEN
                RSS4H :=FALSE;
                END_IF;
                
            (*СБРОС РЕЖИМОВ ПРИ ПЕРЕКЛЮЧЕНИЙ*)
            IF RSS2 OR RSS3 OR RSS4 THEN
                QR1 :=FALSE;
                END_IF;
                
            IF RSS1 OR RSS3 OR RSS4 THEN
                QR2 :=FALSE;
                END_IF;
                
            IF RSS1 OR RSS2 OR RSS4 THEN
                QR3 :=FALSE;
                END_IF;
                
            IF RSS1 OR RSS2 OR RSS3 THEN
                QR4 :=FALSE;
                END_IF;

            IF NOT QR2 AND NOT QR3 AND NOT QR4 THEN
                QR1:=TRUE;
                END_IF;
    (*основной параметр*)
                (*проверка положений*)
                    (*подрежим1*)
                IF Q_SKV_MIN>SAPV21 THEN
                    SPV21:=Q_SKV_MIN;
                END_IF;

                IF SAPV21>Q_SKV_MAX THEN
                    SPV21:=Q_SKV_MAX;
                END_IF;
                
                IF Q_SKV_MAX>=SAPV21 AND SAPV21>=Q_SKV_MIN THEN
                    SPV21:=SAPV21;
                    END_IF;

                    (*подрежим 2 *)
                IF 0>SAPV22 THEN
                    SPV22:=0;
                END_IF;

                IF SAPV22>100 THEN
                    SPV22:=100;
                END_IF;
                
                IF 100>=SAPV22 AND SAPV22>=0 THEN
                    SPV22:=SAPV22;
                    END_IF;

                (*подрежим 3*)
                IF 0>SAPV23 THEN
                    SPV23:=0;
                END_IF;

                IF SAPV23>100 THEN
                    SPV23:=100;
                END_IF;
                
                IF 100>=SAPV23 AND SAPV23>=0 THEN
                    SPV23:=SAPV23;
                    END_IF;

        IF QR1 THEN
            SAPV2P :=SPV21;
            END_IF;

        IF QR2 THEN
            SAPV2P:=SPV22*0.01*Q_SKV_MAX;
            END_IF;

        IF QR3 THEN 
            SAPV2P:=((Q_SKV_MAX-Q_SKV_MIN)/100)*SPV23+Q_SKV_MIN;
            END_IF;                            

        IF QR4 THEN
            SAPV2P:=SAPV24;
            END_IF;
  
           (*ограничение финальной задачи*)

        IF SAPV2P > SHAP2 THEN
            SAPV2:=SHAP2;
            END_IF;

        IF SLAP2 > SAPV2P THEN
            SAPV2:= SLAP2;
            END_IF;

        IF SHAP2 > SAPV2P AND SAPV2P > SLAP2 THEN
            SAPV2:=SAPV2P;
            END_IF;


(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Преобразование значений.************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
    (***********************Масштабирование обратной связи в инженерных единицах.************)    
    IF (SHSI-SLSI) <> 0 THEN
        XCPP := (1.0-((SHSI - LCPX)/(SHSI-SLSI)))*(SHDX-SLDX)+ SLDX; (*Текущее положение в %*) 
    END_IF;
    (***********************Масштабирование управления по шкале канала ************)
    (** OSPX := (1.0-((SHDX-XSPP)/(SHDX-SLDX)))*(SHSO-SLSO) + SLSO;*)
    IF (SAPH-SAPL) <> 0 THEN
        OSPX := (1.0-((SAPH-XSPP_INPID)/(SAPH-SAPL)))*(SHSO-SLSO) + SLSO;
    END_IF;
    (***********************Зона нечувствительности.************)
    IF ABS(SAPH - SAPL) <> 0 THEN
        XDBX := SDBX1/ ABS(SAPH - SAPL) * 10.0; 
    END_IF; 
    
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Аварии и неисправности.************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
        (********************* Блокировка Каскада при неиспрановсти регулироруемого параметра  *********) 
    IF DAPX2 THEN 
        XMMX2 := TRUE;   
        COMM2 := TRUE;
    END_IF;
    
    (********************* Формирование ошибок состояний дистанционного и местного режимов*********)
    FUCX := NOT ILCX AND NOT IRCX;      
    FDCX := ILCX AND IRCX;
    
    (********************* Формирование сигнала обрыв *********)  
    IF ((LCPX <= SLSI - (ABS(SHSI-SLSI)/100.0*3.0) AND (SLSI < SHSI)) OR (LCPX <= SHSI - (ABS(SHSI-SLSI)/100.0*3.0) AND (SHSI < SLSI))) AND (NOT XRPX) AND (NOT DCPX) THEN
        FBXX := TRUE;
    ELSE 
        FBXX := FALSE;
    END_IF;
    (********************* Формирование сигнала КЗ *********)          
    IF ((LCPX >= SHSI + (ABS(SHSI-SLSI)/100.0*3.0) AND (SHSI > SLSI)) OR (LCPX >= SLSI + (ABS(SHSI-SLSI)/100.0*3.0) AND (SLSI > SHSI))) AND (NOT XRPX) AND (NOT DCPX) THEN
        FSCX := TRUE;
    ELSE 
        FSCX := FALSE;
    END_IF;    

    (*********************  Ошибка рассогласования  *********)    
    IF (NOT FXXX) AND (NOT XRPX) AND (NOT DSPX) AND (NOT DCPX) AND (NOT FBXX) AND (NOT FSCX) AND (NOT ILCX) AND (ABS (XSPP - XCPP) >= SMVX) THEN          
        UTR:=UTR + TCYCLE;
        IF UTR > SMVT THEN 
            FMVX := TRUE;
            UTR := 0;
        END_IF;
    END_IF;    
        
    IF FMVX AND ((ABS (XSPP - XCPP)) <= SMVX) THEN 
        FMVX := FALSE;
    END_IF;
       
    (********************* Обобщенная неисправность*********)
    FXXX := (FUCX OR FDCX OR FMVX OR FSCX OR FBXX OR IFXX OR DSPX OR DAPX1 OR DCPX OR DION OR DIOF OR FXXX OR DLCX OR DRCX) AND (NOT XRPX);
    
    (********************* Перевод в ручной режим *********)
    IF FXXX OR FMVX OR XRPX OR CEXX OR ILCX OR DSPX OR DAPX1 THEN
        XMMX1 := TRUE;
        COMM1 := XMMX1; (*Обновление атоматический режим*)
        XMMX2 := TRUE;
        COMM2 := XMMX2; (*Обновление атоматический режим*)        
    END_IF;
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Управление регулятором************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(*Проверка обратного закона регулирования*)
    //1
    IF CCRM1 THEN
        IF SPCX1 > 0 THEN
            SPCX1 := SPCX1 * -1;
        END_IF;
    ELSE
        IF SPCX1 < 0 THEN
            SPCX1 := SPCX1 * -1;
        END_IF;
    END_IF;
    
    BLOCK_PID1.Rej := XMMX1;  

    IF XMMX1 THEN
        BLOCK_PID1.Y:=SSPO;
    END_IF ;
/////////////////////////////////
    IF (NOT XRPX) AND (NOT ILCX) THEN    
        BLOCK_PID1(IAPX1, SLAP1, SHAP1,  FXXX,  SAPV1, 1.0,   2,   0.0,  SLAP1,  SHAP1,  T#4s, SDBX1,  SPCX1,SICX1,SDCX1,STDX1,FALSE, FALSE, SSPL1,   SSPH1, 0.0,  FALSE,FALSE,   FALSE,   FALSE,   FALSE);
        IF XIMX THEN 
            XSPP := LSPP;
        ELSE
            XSPP := BLOCK_PID1.Y;
            XSPP_INPID := BLOCK_PID1.Y;
        END_IF;
    END_IF; 
    //2
    IF CCRM2 THEN
        IF SPCX2 > 0 THEN
            SPCX2 := SPCX2 * -1;
        END_IF;
    ELSE
        IF SPCX2 < 0 THEN
            SPCX2 := SPCX2 * -1;
        END_IF;
    END_IF;
    
    BLOCK_PID2.Rej := XMMX2;  
 //////////////////////////////-----------------------------------------------------------
    IF (NOT XRPX) AND (NOT ILCX) THEN    
        BLOCK_PID2(IAPX2, SLAP2, SHAP2,  FXXX,  SAPV2, 1.0,   2,   0.0,  SLAP2,  SHAP2,  T#4s, SDBX2,  SPCX2,SICX2,SDCX2,STDX2,FALSE, FALSE, SSPL2,   SSPH2, 0.0,  FALSE,FALSE,   FALSE,   FALSE,   FALSE);
 
    END_IF;        
    
    //Включение каскада
    IF (NOT XMMX2 AND NOT XMMX1) THEN
          SAVE_SAPV := SAVE_SAPV + TCYCLE;

        IF SAVE_SAPV > SAPV_SWAP THEN
            SAPV1 := BLOCK_PID2.Y;
            SAVE_SAPV := 0.0;    
        END_IF;
    END_IF;    
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Остальные функции.************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
    (*********************проверка предельных положений*************)
    IF ((P_SKV_MAX>IAPX1) OR (IAPX1<P_SKV_MIN)) AND NOT XMMX1  THEN
        COMM1:=TRUE;
        COMM2:=TRUE;
        FX1:=TRUE;
        ELSE
        FX1:=FALSE;
        END_IF;

    IF ((Q_SKV_MIN>IAPX2) OR (IAPX2>Q_SKV_MAX)) AND NOT XMMX2 THEN
        COMM2:=TRUE;
        COMM1:=TRUE;
        FX2:=TRUE;
        ELSE
        FX2:=FALSE;
        END_IF;

    (********************* Формирование сигналов концевиков*********)                 
    IF ((NOT DCPX) AND (NOT FBXX) AND (NOT FSCX) AND (XCPP <= (SLDX + (ABS(SHDX-SLDX)/100.0*1.0)))) OR (IOFX AND (NOT DIOF)) THEN
        XOFX := TRUE; (*** Регулятор закрыт ****)
    ELSE
        XOFX := FALSE;
    END_IF;
    IF ((NOT DCPX) AND (NOT FBXX) AND (NOT FSCX) AND (XCPP >= (SHDX - (ABS(SHDX-SLDX)/100.0*1.0)))) OR (IONX AND (NOT DION)) THEN
        XONX := TRUE; (***  Регулятор открыт ****)
    ELSE
        XONX := FALSE;
    END_IF;

    (****************Реализация безударного перехода при проявлении дистанционного режима*********)
    IF (ILCX) AND (NOT DCPX) AND (NOT FBXX) AND (NOT FSCX) THEN
        SSPO := XCPP; (****Перекладка текущего % открытия в задание от оператора***)
    END_IF;   
    
    (****************Реализация безударного перехода при выводе из режима ремонт*********)
    IF XRPX AND (NOT DCPX) AND (NOT FBXX) AND (NOT FSCX) THEN
        SSPO := XCPP; // Перекладка текущего % открытия в задание от оператора 
    END_IF;            
    
    (*************** Реализация безударного перехода при переключении в автоматический режим *******)
    IF  (( XMMX1_prev) AND NOT XMMX1)THEN
        SAPV1 := IAPX1; (****Перекладка значения регулируемого параметра в уставку регулирования***)
    END_IF;
                                                                                             
    
    (*****Реализация безударного перехода при переключении в ручной режим *****)    

    IF NOT XMMX1_prev AND XMMX1 OR (CEXX_prev AND (NOT CEXX)) THEN
       SSPO := XCPP;  (****Перекладка ручного % управления в задание % от оператора***)
    END_IF;

    (************* Задание управления при блокировке\нормальном останове *********************)

    IF NOT CEXX AND NOT XRPX AND CENX THEN
        COMM1 := TRUE;
        SSPO := SENX;
    END_IF; 

    (************************** Задание управления при команде ПАЗ ***************************)     

    IF (CEXX AND (NOT XRPX)) THEN
        COMM1 := TRUE; // Сброс в ручное управление 
        SSPO := SEPX;
    END_IF;
    IF XRPX THEN 
        FMVX := FALSE;
    END_IF; 
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
(***********************Сохранение значений с предыдущего цикла.************)
(**************************************************************************************************)
(**************************************************************************************************)
(**************************************************************************************************)
    //1
    SPCX1_prev := SPCX1; (***********************Пропорциональный коэффициент.************) 
    SDCX1_prev := SDCX1; (***********************Дифференциальный коэффициент.************)  
    XMMX1_prev := XMMX1; (***********************ручной / автоматический режим.************)        
     
    //2
    SPCX2_prev := SPCX2; (***********************Пропорциональный коэффициент.************) 
    SDCX2_prev := SDCX2; (***********************Дифференциальный коэффициент.************)   
    XMMX2_prev := XMMX2; (***********************ручной / автоматический режим.************)    
    ///
    SMVT_prev := SMVT; (***********************Уставка времени рассогласования.************) 
    
END_FUNCTION_BLOCK
